    // Sort by id (date miliseconds) to get newest score
    const sortDBWOScore = [...WOScore.DBWOScore].sort((a, b) => b.id - a.id);
    sortDBWOScore.forEach((data) => {
      htmlJourney += `
        <div
          class="mb-3 w-full border-t-2 border-yellow-200 bg-white flex flex-row justify justify-between px-3 py-1.5"
        >
          <div class="flex flex-col items-start justify-between">
            <div class="flex flex-row items-center">
              <div class="text-md text-gray-600 font-semibold mr-2">
                ${data.nameWorkout}
              </div>
              <div
                class="text-xs px-1 py-0.5 bg-gray-200 rounded-lg text-gray-600 font-semibold"
              >
                ${data.duration}
              </div>
            </div>
            <div class="text-xs">${data.date}</div>
          </div>
          <div class="flex flex-col items-center justify-between">
            <div class="text-xl font-semibold text-gray-600">${data.repetition}</div>
            <div class="text-xs">Reps</div>
          </div>
        </div>
      `;
    });
    bodyJourneyElem.innerHTML = htmlJourney;
    bodyBestScoreElem.innerHTML = htmlBestScore;
    scoresElem.style.display = "flex";
  });

  scoresOKBtnElem.addEventListener("click", () => {
    scoresElem.style.display = "none";
  });

  segJourneyBtnElem.addEventListener("click", () => {
    // Show body journey element
    if (bodyJourneyElem.style.display !== "none") return;
    bodyBestScoreElem.style.display = "none";
    bodyJourneyElem.style.display = "block";
    segBestBtnElem.classList.remove("bg-amber-300", "text-gray-600");
    segBestBtnElem.classList.add("bg-amber-200", "text-gray-400");
    segJourneyBtnElem.classList.remove("bg-amber-200", "text-gray-400");
    segJourneyBtnElem.classList.add("bg-amber-300", "text-gray-600");
  });

  segBestBtnElem.addEventListener("click", () => {
    // Show body best score element
    if (bodyBestScoreElem.style.display !== "none") return;
    bodyJourneyElem.style.display = "none";
    bodyBestScoreElem.style.display = "block";
    segJourneyBtnElem.classList.remove("bg-amber-300", "text-gray-600");
    segJourneyBtnElem.classList.add("bg-amber-200", "text-gray-400");
    segBestBtnElem.classList.remove("bg-amber-200", "text-gray-400");
    segBestBtnElem.classList.add("bg-amber-300", "text-gray-600");
  });

  segSettingsWOBtnElem.addEventListener("click", () => {
    // Show body settings (choose WO) element
    if (bodySettingsWOElem.style.display !== "none") return;
    bodySettingsAdvElem.style.display = "none";
    bodySettingsWOElem.style.display = "block";
    segSettingsAdvBtnElem.classList.remove("bg-amber-300", "text-gray-600");
    segSettingsAdvBtnElem.classList.add("bg-amber-200", "text-gray-400");
    segSettingsWOBtnElem.classList.remove("bg-amber-200", "text-gray-400");
    segSettingsWOBtnElem.classList.add("bg-amber-300", "text-gray-600");
  });

  segSettingsAdvBtnElem.addEventListener("click", () => {
    // Show body advance settings element
    if (bodySettingsAdvElem.style.display !== "none") return;
    bodySettingsWOElem.style.display = "none";
    bodySettingsAdvElem.style.display = "block";
    segSettingsWOBtnElem.classList.remove("bg-amber-300", "text-gray-600");
    segSettingsWOBtnElem.classList.add("bg-amber-200", "text-gray-400");
    segSettingsAdvBtnElem.classList.remove("bg-amber-200", "text-gray-400");
    segSettingsAdvBtnElem.classList.add("bg-amber-300", "text-gray-600");
  });

  settingsBtnElem.addEventListener("click", () => {
    // Show modal / pop up settings element (choose WO & advance settings)
    settingsElem.style.display = "flex";
    // Get and show current settings
    document.querySelector(
      `input[value="${WOSettings.DBWOSettings.currWorkout}"][name="settingsNameWO"]`
    ).checked = true;
    document.querySelector(
      `input[value="${WOSettings.DBWOSettings.currDuration}"][name="settingsDurationWO"]`
    ).checked = true;
    document.querySelector('input[name="settingsAEBox"]').checked =
      WOSettings.DBWOSettings.isAudioEffect !== undefined
        ? WOSettings.DBWOSettings.isAudioEffect
        : true; // Default setting Audio Effect
    document.querySelector('input[name="settingsFSBox"]').checked =
      WOSettings.DBWOSettings.isFullscreen !== undefined
        ? WOSettings.DBWOSettings.isFullscreen
        : false; // Default setting Full Screen
    document.querySelector('input[name="settingsFCBox"]').checked =
      WOSettings.DBWOSettings.isFlipCamera !== undefined
        ? WOSettings.DBWOSettings.isFlipCamera
        : false; // Default setting Flip Camera
    document.querySelector('input[name="settingsDSBox"]').checked =
      WOSettings.DBWOSettings.isDirectionSign !== undefined
        ? WOSettings.DBWOSettings.isDirectionSign
        : true; // Default setting Direction Sign
    document.querySelector('input[name="settingsDMBox"]').checked =
      WOSettings.DBWOSettings.isDeveloperMode !== undefined
        ? WOSettings.DBWOSettings.isDeveloperMode
        : false; // Default setting Developer Mode
  });

  const actionSettings = {
    currWorkoutDuration: async (data) => {
      loaderElem.style.display = "flex";
      delayElem.innerText = "";
      webcamElem.pause();
      WOPose.isLoop = false;
      isFirstPlay = true;
      isWebcamSecPlay = true;
      WOPose.counter.lastStage = {};
      WOPose.counter.nextStage = {};

      if (data.durationWO.isChange) {
        WOTimer.setup({
          interval: 1000,
          duration: WOPose.isVideoMode
            ? Math.floor(webcamElem.duration)
            : 60 * +data.durationWO.value.split(" ")[0],
          type: "DEC",
          firstDelayDuration: WOPose.isVideoMode ? 0 : 3,
        });

        setCurrTime();
        const title = `${WOPose.counter.rules.nameWorkout} - ${data.durationWO.value}`;
        titleWOElem.innerText = title;
        resultTitleElem.innerText = title;
      }
      if (data.nameWO.isChange) {
        await setupChangeWO(`./rules/${data.nameWO.value}.json`);
      }

      WOTimer.isFirstDelay = !WOPose.isVideoMode;
      if (WOPose.isVideoMode && webcamElem.currentTime !== 0) {
        webcamElem.currentTime = 0;
        webcamElem.load();
      }

      WOTimer.pause();
      // Clear screen
      imgDirectionSignElem.style.display = "none";
      adviceWrapElem.style.display = "none";
      resumeBtnElem.style.display = "flex";
      restartBtnElem.style.display = "none";
      pauseBtnElem.style.display = "none";
      loaderElem.style.display = "none";
    },
    isAudioEffect: (data) => {
      WOPose.counter.isPlayAudStage = data;
      WOTimer.isPlayAudTimer = data;
    },
    isFullscreen: (data) => {
      if (data && !document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else if (
        !data &&
        document.exitFullscreen &&
        document.fullscreenElement
      ) {
        document.exitFullscreen();
      }
    },
    isFlipCamera: (data) => {
      // Default (user for webcam) and auto change to "environment" if video
      const facingMode = data ? "environment" : "user";
      WOPose.camHandler.flip(facingMode);
    },
    isDirectionSign: (data) => {
      // Toggler to show direction sign
      WOPose.isShowDirectionSign = data;
      if (WOPose.isClassify) {
        imgDirectionSignElem.style.display = data ? "block" : "none";
      }
    },
    isDeveloperMode: (data) => {
      // Toggler to show developer mode element
      developerModeElem.style.display = data ? "flex" : "none";
    },
  };

  saveSettingsBtnElem.addEventListener("click", () => {
    // Get newest data settings
    const currWorkout = document.querySelector(
      'input[name="settingsNameWO"]:checked'
    ).value;
    const currDuration = document.querySelector(
      'input[name="settingsDurationWO"]:checked'
    ).value;
    const isAudioEffect = document.querySelector(
      'input[name="settingsAEBox"]'
    ).checked;
    const isFullscreen = document.querySelector(
      'input[name="settingsFSBox"]'
    ).checked;
    const isFlipCamera = document.querySelector(
      'input[name="settingsFCBox"]'
    ).checked;
    const isDirectionSign = document.querySelector(
      'input[name="settingsDSBox"]'
    ).checked;
    const isDeveloperMode = document.querySelector(
      'input[name="settingsDMBox"]'
    ).checked;

    // Send newest settings to check and get change
    WOSettings.change(
      {
        currWorkout,
        currDuration,
        isAudioEffect,
        isFullscreen,
        isFlipCamera,
        isDirectionSign,
        isDeveloperMode,
      },
      actionSettings
    );
    settingsElem.style.display = "none";
  });

  cancelSettingsBtnElem.addEventListener("click", () => {
    settingsElem.style.display = "none";
  });

  // Get configuration of scores
  const setupWOScore = async (path) => {
    await fetch(path)
      .then((resp) => {
        if (!resp.ok) {
          throw new Error(`HTTP error${resp.status}`);
        }
        return resp.json();
      })
      .then(async (data) => {
        formChooseWOElem.innerHTML = getHTMLChooseWO(data, false);
        bodySettingsWOElem.innerHTML = getHTMLChooseWO(data, true);
        document
          .getElementById("chooseHelpBtn")
          .addEventListener("click", () => {
            helpElem.style.display = "flex";
          });
        // Init and try to load localStorage data scores
        WOScore.setup(data);
        // Init and try to load localStorage data settings
        WOSettings.setup(data.settingsConfig, {
          isFlipCamera: actionSettings.isFlipCamera,
          isDeveloperMode: actionSettings.isDeveloperMode,
        });
        if (
          WOSettings.isGetPrevSettings &&
          WOSettings.DBWOSettings.currWorkout &&
          WOSettings.DBWOSettings.currWorkout !== "None"
        ) {
          loaderElem.style.display = "flex";
          await setupChangeWO(
            `./rules/${WOSettings.DBWOSettings.currWorkout}.json`
          );
        } else {
          chooseWOElem.style.display = "flex";
          loaderElem.style.display = "none";
        }
      })
      .catch((e) => {
        console.error(e);
      });
  };

  await setupWOScore("./mock-data/workout.json");

  // Just for initial (once run)
  // It will be remove when replaced by new webcamElem
  // Check: uploadVideoBtnElem
  webcamElem.addEventListener("loadeddata", () => {
    if (!WOPose.isVideoMode) {
      if (WOPose.isClassify) {
        WOPose.isClassify = false;
      }
      WOPose.isLoop = true;
      sliderCameraElem.checked = true;
      if (isWebcamSecPlay) {
        isWebcamSecPlay = false;
      }
      delayElem.innerText = "";
      WOTimer.pause();
      WOPose.counter.resetCount();
      WOPose.drawPose();
    }
  });

  accessCamBtnElem.addEventListener("click", async () => {
    await getAccessCam();
  });

  formChooseWOElem.addEventListener("submit", async (event) => {
    event.preventDefault();
    // Get user choice
    const workout = document.querySelector(
      'input[name="chooseNameWO"]:checked'
    ).value;
    const duration = document.querySelector(
      'input[name="chooseDurationWO"]:checked'
    ).value;
    if (event.submitter.id === "submitWOBtn") {
      // Change without action as initial run (first play)
      WOSettings.change({
        currWorkout: workout,
        currDuration: duration,
      });
      chooseWOElem.style.display = "flex";
      loaderElem.style.display = "flex";
      await setupChangeWO(`./rules/${workout}.json`);
    }
  });

  // Callback to update and show delay time
  const delayCB = (time) => {
    delayElem.innerText = time;
  };
  // Callback when delay time is finished
  const finishDelayCB = () => {
    delayElem.innerText = "";
  };
  // Callback to update and show current time
  const timerCB = (time) => {
    timerElem.innerText = `${`0${time.minutes}`.slice(
      -2
    )}:${`0${time.seconds}`.slice(-2)}`;
  };
  // Callback when timer is finished
  const finishTimerCB = () => {
    // Only save when not video mode
    if (!WOPose.isVideoMode) {
      WOScore.addNewData({
        id: +new Date(),
        nameWorkout: WOPose.counter.rules.nameWorkout,
        duration: WOSettings.DBWOSettings.currDuration,
        repetition: WOPose.counter.count,
        date: new Date().toLocaleString(),
      });
    }
    setCurrTime();
    WOTimer.isFirstDelay = !WOPose.isVideoMode;
    resultRepElem.innerText = WOPose.counter.count;
    WOTimer.start(delayCB, finishDelayCB, timerCB, finishTimerCB);
    WOTimer.pause();
    webcamElem.pause();
    isFirstPlay = true;
    WOPose.isLoop = false;
    WOPose.counter.resetCount();
    WOPose.counter.lastStage = {};
    WOPose.counter.nextStage = {};
    resultElem.style.display = "flex";
    resumeBtnElem.style.display = "flex";
    restartBtnElem.style.display = "none";
    pauseBtnElem.style.display = "none";
    imgDirectionSignElem.style.display = "none";
    adviceWrapElem.style.display = "none";
  };

  // Fired when timer is finished and try to restart with OK btn
  resultOKBtnElem.addEventListener("click", () => {
    resultElem.style.display = "none";
    if (isFirstPlay && WOPose.isVideoMode) {
      webcamElem.pause();
      webcamElem.currentTime = 0;
      webcamElem.load();
    } else {
      WOTimer.reset();
      setCurrTime();
    }
  });

  // Pause webcam or video
  pauseBtnElem.addEventListener("click", () => {
    WOTimer.pause();
    webcamElem.pause();
    WOPose.isLoop = false;
    resumeBtnElem.style.display = "flex";
    restartBtnElem.style.display = "flex";
    pauseBtnElem.style.display = "none";
  });

  // Play or resume button for video and webcam
  resumeBtnElem.addEventListener("click", () => {
    if (!isFirstPlay && !webcamElem.paused && WOPose.isLoop) return;
    pauseBtnElem.style.display = "flex";
    restartBtnElem.style.display = "none";
    resumeBtnElem.style.display = "none";
    const firstPlay = isFirstPlay;

    if (isFirstPlay) {
      isFirstPlay = false;
      WOPose.isClassify = true;
      WOTimer.start(delayCB, finishDelayCB, timerCB, finishTimerCB);
    }

    WOTimer.resume();
    WOPose.isLoop = true;
    webcamElem.play().then(() => {
      if (!isWebcamSecPlay && firstPlay && !WOPose.isVideoMode) {
        console.log("It run?");
        isWebcamSecPlay = true;
        // Return to stop redraw again (first play)
        return;
      }
      WOPose.drawPose();
    });
  });

  uploadVideoBtnElem.addEventListener("change", (event) => {
    if (event.target.files && event.target.files[0]) {
      // Stop webcam first before replace with video
      WOPose.camHandler.stop();
      WOPose.isClassify = true;
      WOPose.isLoop = false;
      WOPose.isVideoMode = true;
      webcamElem.pause();
      // Remove current webcamElem to fix error pose detector
      // during transition source webcam to video (it's async, not directly changing)
      webcamElem.remove();

      const newWebcamElem = document.createElement("video");
      newWebcamElem.setAttribute("id", "webcamBox");
      newWebcamElem.setAttribute("class", "bg-gray-200 z-10");
      newWebcamElem.setAttribute(
        "style",
        `width: ${widthResult}px; height: ${heightResult}px`
      );
      newWebcamElem.muted = true;

      parentWebcamElem.insertBefore(newWebcamElem, parentWebcamElem.firstChild);

      newWebcamElem.setAttribute(
        "src",
        URL.createObjectURL(event.target.files[0])
      );
      newWebcamElem.load();
      newWebcamElem.play();
      // When first time upload video, the facingMode is always "environment"
      // So we need to flip true ("environment" mode) to draw canvas properly
      WOSettings.change(
        { isFlipCamera: true },
        { isFlipCamera: actionSettings.isFlipCamera }
      );

      newWebcamElem.addEventListener("loadeddata", () => {
        if (WOPose.isVideoMode) {
          webcamElem = newWebcamElem;
          WOPose.webcamElem = newWebcamElem;
          // This is for prepare when to switch to webcam again
          // eslint-disable-next-line no-underscore-dangle
          WOPose.camHandler._webcamElement = newWebcamElem;
        }
        WOPose.counter.resetCount();
        countElem.innerText = "0";
        delayElem.innerText = "";
        WOTimer.setup({
          interval: 1000,
          duration: WOPose.isVideoMode
            ? Math.floor(webcamElem.duration)
            : 60 * +WOSettings.DBWOSettings.currDuration.split(" ")[0],
          type: "DEC",
          firstDelayDuration: WOPose.isVideoMode ? 0 : 3,
        });
        WOTimer.isFirstDelay = !WOPose.isVideoMode;
        WOTimer.pause();
        setCurrTime();
        webcamElem.pause();
        WOPose.counter.lastStage = {};
        WOPose.counter.nextStage = {};
        if (widthRealVideo !== 0 && WOPose.isVideoMode) {
          heightRealVideo = newWebcamElem.videoHeight;
          widthRealVideo = newWebcamElem.videoWidth;
        }
        WOPose.scaler = {
          w: widthResult / widthRealVideo,
          h: heightResult / heightRealVideo,
        };
        WOPose.classifier.stdConfig = {
          width: widthRealVideo,
          height: heightRealVideo,
        };
        resumeBtnElem.style.display = "flex";
        restartBtnElem.style.display = "none";
        pauseBtnElem.style.display = "none";
        imgDirectionSignElem.style.display = "none";
        adviceWrapElem.style.display = "none";
        sliderCameraElem.checked = !WOPose.isVideoMode;
      });
    }
  });

  // Advice auto show when classifier is running
  goAdviceBtnElem.addEventListener("click", (event) => {
    event.preventDefault();
    WOPose.isShowAdvice = !WOPose.isShowAdvice;
    sliderAdviceElem.checked = WOPose.isShowAdvice;
    if (WOPose.isClassify) {
      adviceWrapElem.style.display = WOPose.isShowAdvice ? "flex" : "none";
    }
  });

  goWebcamBtnElem.addEventListener("click", async (event) => {
    event.preventDefault();
    if (!WOPose.isVideoMode) return;
    widthRealVideo = 640;
    heightRealVideo = 360;
    // Constraint settings for webcam
    // eslint-disable-next-line no-underscore-dangle
    WOPose.camHandler._addVideoConfig = {
      width: widthRealVideo,
      height: heightRealVideo,
    };
    WOPose.classifier.stdConfig = {
      width: widthRealVideo,
      height: heightRealVideo,
    };
    WOPose.isLoop = false;
    isWebcamSecPlay = true;
    sliderCameraElem.checked = true;
    WOPose.isVideoMode = false;
    await WOPose.camHandler.start();
  });
});